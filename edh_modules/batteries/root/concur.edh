
/**
 * schedule a number of tasks to run concurrently, but with
 * concurrency limit specified by 'c'
 *
 * each task must be a nullary procedure (i.e. a niladic 
 * computation)
 *
 * pass 'runtime.debug' or even 'runtime.info' as 'dbgLogger'
 * to see verbose log of the finishing up
 */
method concur(*tasks, c=6, dbgLogger=0) {
  null(tasks) -> return nil
  c < 1 -> error("Invalid concurrency: " ++ c)

  // event sink for decreased number of running tasks, this will
  // read zero after all done. only start to fire after all tasks 
  // have been put to running, and the running count drops below
  // c, i.e. started to finish up
  doneSig = sink

  // use a class to manage 'tasks' and 'cntRunning' as instance
  // attributes, an attribute belonging to a method proc (`concur()`
  // in this case) is not possible to be assigned from another
  // procedure (the later `scheduleMore()` method in this case)
  class Scheduler(
    // arguments to a class (constructor) procedure automatically
    tasks // become instance attributes
  ){

    // this somewhat emulates a WaitGroup in Go
    cntRunning = 0 // 'this.' at ctor proc scope is optional

    method scheduleMore() {

      // snoc this.tasks within an *atoiso* tx block
      ai case this.tasks of {

        {()} -> task2do = nil // no more tasks in backlog

        { task2do => rest } -> // one task taken out of backlog
          this.tasks = rest // update this.task within tx

      }

      if nil == task2do then {
        doneSig <- cntRunning // notify about overall finishing up
        return nil // skip all following code
      }

      // start a new thread (goroutine) to run 'task2do'
      go {
        // use `defer` to always run upon thread termination,
        // this is necessary as code after `task2do()` may not
        // get actually executed in case this thread is broken by
        // an event reactor registered during `task2do()`
        defer {
          this.cntRunning -= 1 // this is atomic in Edh
          if this.cntRunning < c then this.scheduleMore()
        }
        task2do()
      }
      // similar to WaitGroup.Add() in Go
      this.cntRunning += 1 // this is atomic in Edh

    }
  }

  schd = Scheduler(tasks)
  while not null(schd.tasks) && schd.cntRunning < c
    schd.scheduleMore()
  
  for n from doneSig do if n < 1 then {
    dbgLogger <| '  ðŸŽ‰  all concur tasks done.'
    return nil // don't forget to break out the 'doneSig' event loop
  } else
    dbgLogger <| '  â²ï¸  finishing up concur tasks, ' ++ n ++ ' left running.'
}
