
  /**
   * resembles `range` in Python
   */
  generator range(start, stop=nil, step=nil) {
    if stop == nil then let (stop, start) = (start, 0)
    start == stop -> return nil
    n = start
    
    start < stop -> {
      if step == nil
        then step = 1
        else if step <= 0 then {
          runtime.warn <| 'step of ' ++ step ++ ' for range [' ++
                          start ++ ', ' ++ stop ++ ") won't converge"
          return nil
        }
      while n < stop {
        yield n
        n += step
      }
    }

    start > stop -> {
      if step == nil
        then step = -1
        else if step >= 0 then {
          runtime.warn <| 'step of ' ++ step ++ ' for range [' ++
                          start ++ ', ' ++ stop ++ ") won't converge"
          return nil
        }
      while n > stop {
        yield n
        n += step
      }
    }
  }

  /**
   * resembles `enumerate` in Python
   *
   * enumerating tuple/list/dict is quite the same, but to enumerate
   * a generator, you need to pass the generator proc here followed by
   * its args, instead of calling it your self. as generators in Edh
   * can only be call by a for-from-do loop.
   */
  generator enumerate(g, ***gargs) {
    n = 0
    case type(g) of {

      GeneratorType -> for i from g(***gargs) do {
        yield pkargs(n, i)
        n += 1

      }

      if not null(gargs) then
        runtime.warn <| '`enumerate` can hanle one series only'

      _ -> for i from g do {
        yield pkargs(n, i)
        n += 1
      }

    }
  }

  // args repacking is rather inefficient compared to snoc, we can
  // expose snoc as a host proc and leverage that here, but we are
  // still limited to zip tuple/list only, can not handle events from
  // sinks. I doubt the overall usefulness of zips in Edh, given we
  // are focused on event hosting

  generator zip(xs, ys) {
    while not null(xs) && not null(ys) {
      let (x, *xs) = (*xs)
      let (y, *ys) = (*ys)
      yield (x, y)
    }
  }

  generator zip3(xs, ys, zs) {
    while not null(xs) && not null(ys) && not null(zs) {
      let (x, *xs) = (*xs)
      let (y, *ys) = (*ys)
      let (z, *zs) = (*zs)
      yield (x, y, z)
    }
  }
