
  generator range(start, stop=nil, step=nil) {
    if stop == nil then let (stop, start) = (start, 0)
    start == stop -> return nil
    n = start
    
    start < stop -> {
      if step == nil
        then step = 1
        else if step <= 0 then {
          runtime.warn <| 'step of ' ++ step ++ ' for range [' ++
                          start ++ ', ' ++ stop ++ ") won't converge"
          return nil
        }
      while n < stop {
        yield n
        n += step
      }
    }

    start > stop -> {
      if step == nil
        then step = -1
        else if step >= 0 then {
          runtime.warn <| 'step of ' ++ step ++ ' for range [' ++
                          start ++ ', ' ++ stop ++ ") won't converge"
          return nil
        }
      while n > stop {
        yield n
        n += step
      }
    }
  }

  /**
   * a generator procedure can only be call by a for-from-do loop,
   * to enumerate a generator, pass its args following it, instead
   * of calling it your self.
   */
  generator enumerate(g, ***gargs) {
    n = 0
    case type(g) of {

      GeneratorType -> for i from g(***gargs) do {
        yield pkargs(n, i)
        n += 1

      }

      _ -> for i from g do {
        yield pkargs(n, i)
        n += 1
      }
    }
  }


  generator zip(xs, ys) {
    while not null(xs) && not null(ys) {
      let (x, *xs) = (*xs)
      let (y, *ys) = (*ys)
      yield (x, y)
    }
  }

  generator zip3(xs, ys, zs) {
    while not null(xs) && not null(ys) && not null(zs) {
      let (x, *xs) = (*xs)
      let (y, *ys) = (*ys)
      let (z, *zs) = (*zs)
      yield (x, y, z)
    }
  }
