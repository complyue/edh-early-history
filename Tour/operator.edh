
# Some fancy chars can be used in operators
#
# ğŸ”€ğŸ”ğŸ”‚â©âªğŸ”¼â«ğŸ”½â¬â¹ï¸
# ğŸŒ€ğŸ“¢ğŸ“£ğŸ””ğŸ”•ğŸµâ­•
# ğŸ†”ğŸ†˜ğŸ†š

{
  operator ğŸ“£ 5 (lhv, rhv) {
    runtime.info <| rhv ++ ' is telling ' ++ lhv
  }

  operator ğŸ†š 1 (lhv, rhv) {
    runtime.info <| "ğŸŒ€ What's the difference?\n     "
      ++ lhv ++ '\n  ğŸ†š\n     ' ++ rhv
  }
}

'a tale' ğŸ“£ 'the goat'

let (a, b) = ( 'Orange', 'Apple', )
a ğŸ†š b


{
  method localOverrides * {
    # overide the (++) operator within this procedure only, avoid
    # polluting the module scope

    before = 'You' ++ ' and ' ++ 'me'
    operator ++ (lhv, rhv) {
      # inside the overriding operator definition, the overridden,
      # original operator is available as was before the overide
      lhv ++ ' â­• ' ++ rhv
    }
    after = 'You' ++ ' and ' ++ 'me'

    before ğŸ†š after
  }
}

localOverrides()


{
  # save the original (=<) operator, use it for append as (<=<)
  append'operator = (=<)
  operator <=< 1 (lhv, rhv) {
    # restore the original (=<) operator
    (=<) = append'operator
    # do it
    lhv =< rhv
  }

  # override operator (=<) to comprehend into empty ones only
  operator =< (callerScope, lhe, rhe) {
    lhv = callerScope.eval(lhe)
    if not null(lhv) then
      error("You don't comprehend into non-empty ones!")
    # left-hand value is empty, can do it
    rhv = callerScope.eval(rhe)
    # the overridden original operator is captured for an 
    # overriding operator automatically, so just use it
    lhv =< rhv
  }
}

[3,2] =< [7,5]

[3,2] <=< [7,5]
